import {
  exportKeyToBase64,
  generateKey,
} from '@shared/lib/crypto/operations';
import { parse, stringify } from 'envfile';
import { appendFile, readFile, writeFile } from 'fs/promises';
import { resolve } from 'path';
import { cwd } from 'process';
import { VaultDBConfig } from '@shared/types/config';
import { createSecretsHelpers } from '@shared/db/secrets';
import { initDBClient } from 'db/init';

type EnvVars = Record<string, string>;

const encoding: BufferEncoding = 'utf-8';

export async function syncEnv(
  filePath: string,
  envVars: EnvVars,
  append = false,
) {
  const fullPath = resolve(cwd(), filePath);

  const envAsString = stringify(envVars);

  const envContent = `# generated by deadrop\n\n${envAsString}\n`;

  if (append) await appendFile(fullPath, `\n${envContent}`, encoding);
  else await writeFile(fullPath, envContent, encoding);
}

export async function loadEnvFromFile(filePath: string) {
  const fullPath = resolve(cwd(), filePath);
  console.log(fullPath);
  const envContent = await readFile(fullPath, encoding);

  const parsedEnv = parse(envContent);

  return parsedEnv;
}

export async function initEnvKey() {
  const environmentKey = await generateKey();

  return exportKeyToBase64(environmentKey);
}

export async function addEnvToVault(
  envPath: string,
  environment: string,
  vault: VaultDBConfig,
) {
  const envVars = await loadEnvFromFile(envPath);

  // generate key for environment
  if (!vault.environments[environment])
    vault.environments[environment] = await initEnvKey();

  // TODO update .deadroprc file

  const secretsToAdd = Object.entries(envVars).map(
    ([key, value]) => ({
      name: key,
      environment,
      value,
    }),
  );

  const db = await initDBClient(
    vault.location,
    vault.key,
    vault.cloud,
  );

  const { addSecrets } = createSecretsHelpers(vault, db);

  return addSecrets(secretsToAdd);
}
